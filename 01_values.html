<!doctype html>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-158904079-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-158904079-1');
  </script>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Valores, Tipos, y Operadores :: Eloquent JavaScript</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script><script>var chapNum = 1;</script></head>

<article>
<nav><a href="00_intro.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="02_program_structure.html" title="next chapter">▶</a></nav>

<h1><span class=chap_num>Chapter 1</span>Valores, Tipos, y Operadores</h1>

<blockquote>

<p><a class="p_ident" id="p_rWyEyGCy4+" href="#p_rWyEyGCy4+" tabindex="-1" role="presentation"></a>Debajo de la superficie de la máquina, el programa se mueve. Sin esfuerzo, se expande y se contrae. En gran armonía, los electrones se dispersan y se reagrupan. Las figuras en el monitor son tan solo ondas sobre el agua. La esencia se mantiene invisible debajo de la superficie.</p>

<footer>Master Yuan-Ma, <cite>The Book of Programming</cite></footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_1.jpg" alt="Una foto de un mar de bits"></figure>

<p><a class="p_ident" id="p_hdavwd5apD" href="#p_hdavwd5apD" tabindex="-1" role="presentation"></a>Dentro del mundo de la computadora, solo existen datos. Puedes leer datos, modificar datos, crear nuevos datos—pero todo lo que no sean datos, no puede ser mencionado. Toda estos datos están almacenados como largas secuencias de bits, y por lo tanto, todos los datos son fundamentalmente parecidos.</p>

<p><a class="p_ident" id="p_6v7/b19cIR" href="#p_6v7/b19cIR" tabindex="-1" role="presentation"></a>Los <em>bits</em> son cualquier tipo de cosa que pueda tener dos valores, usualmente descritos como ceros y unos. Dentro de la computadora, estos toman formas tales como cargas eléctricas altas o bajas, una señal fuerte o débil, o un punto brillante u opaco en la superficie de un CD. Cualquier pedazo de información discreta puede ser reducida a una secuencia de ceros y unos y, de esa manera ser representada en bits.</p>

<p><a class="p_ident" id="p_cNu2dw7MSS" href="#p_cNu2dw7MSS" tabindex="-1" role="presentation"></a>Por ejemplo, podemos expresar el numero 13 en bits. Funciona de la misma manera que un número decimal, pero en vez de 10 diferentes dígitos, solo tienes 2, y el peso de cada uno aumenta por un factor de 2 de derecha a izquierda. Aquí tenemos los bits que conforman el número 13, con el peso de cada dígito mostrado debajo de el:</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_+fMMNc3yUt" href="#c_+fMMNc3yUt" tabindex="-1" role="presentation"></a>   0   0   0   0   1   1   0   1
 128  64  32  16   8   4   2   1</pre>

<p><a class="p_ident" id="p_bc39DFUofb" href="#p_bc39DFUofb" tabindex="-1" role="presentation"></a>Entonces ese es el número binario 00001101, o 8 + 4 + 1, o 13.</p>

<h2><a class="h_ident" id="h_U9F8ZU147i" href="#h_U9F8ZU147i" tabindex="-1" role="presentation"></a>Valores</h2>

<p><a class="p_ident" id="p_KQuiE3XsoV" href="#p_KQuiE3XsoV" tabindex="-1" role="presentation"></a>Imagina un mar de bits, un océano de ellos. Una computadora moderna promedio tiene mas de 30 billones de bits en su almacenamiento de datos volátiles (memoria funcional). El almacenamiento no volátil (disco duro o equivalente) tiende a tener unas cuantas mas ordenes de magnitud.</p>

<p><a class="p_ident" id="p_q6vfgg9FAg" href="#p_q6vfgg9FAg" tabindex="-1" role="presentation"></a>Para poder trabajar con tales cantidades de bits sin perdernos, debemos separarlos en porciones que representen pedazos de información. En un entorno de JavaScript, esas porciones son llamadas <em>valores</em>. Aunque todos los valores están hechos de bits, estos juegan papeles diferentes. Cada valor tiene un tipo que determina su rol. Algunos valores son números, otros son pedazos de texto, otros son funciones, y asi sucesivamente.</p>

<p><a class="p_ident" id="p_Iamt82VWK9" href="#p_Iamt82VWK9" tabindex="-1" role="presentation"></a>Para crear un valor, solo debemos de invocar su nombre. Esto es conveniente. No tenemos que recopilar materiales de construcción para nuestros valores, o pagar por ellos. Solo llamamos su nombre, y <em>woosh</em>, ahi lo tienes. Estos no son realmente creados de la nada, por supuesto. Cada valor tiene que ser almacenado en algún sitio, y si quieres usar una cantidad gigante de valores al mismo tiempo, puede que te quedes sin memoria. Afortunadamente, esto solo es un problema si los necesitas todos al mismo tiempo. Tan pronto como dejes de utilizar un valor, este se disipará, dejando atrás sus bits para que estos sean reciclados como material de construcción para la próxima generación de valores.</p>

<p><a class="p_ident" id="p_FaJfZjjulx" href="#p_FaJfZjjulx" tabindex="-1" role="presentation"></a>Este capitulo introduce los elementos atómicos de los programas en JavaScript, estos son, los tipos de valores simples y los operadores que actúan en tales valores.</p>

<h2><a class="h_ident" id="h_2eDSr4FTTr" href="#h_2eDSr4FTTr" tabindex="-1" role="presentation"></a>Números</h2>

<p><a class="p_ident" id="p_h2dGq/FT9C" href="#p_h2dGq/FT9C" tabindex="-1" role="presentation"></a>Valores del tipo <em>number</em> (número) son, como es de esperar, valores numéricos. En un programa hecho en JavaScript, se escriben de la siguiente manera:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_/u5ErTZbax" href="#c_/u5ErTZbax" tabindex="-1" role="presentation"></a><span class="cm-number">13</span></pre>

<p><a class="p_ident" id="p_gP8JnTD/50" href="#p_gP8JnTD/50" tabindex="-1" role="presentation"></a>Utiliza eso en un programa, y ocasionara que el patrón de bits que representa el número 13 sea creado dentro de la memoria de la computadora.</p>

<p><a class="p_ident" id="p_jUtRrpp8gl" href="#p_jUtRrpp8gl" tabindex="-1" role="presentation"></a>{{index [number, representación], bit}}</p>

<p><a class="p_ident" id="p_2APgdtJ69N" href="#p_2APgdtJ69N" tabindex="-1" role="presentation"></a>JavaScript utiliza un número fijo de bits, específicamente 64 de ellos, para almacenar un solo valor numérico. Solo existen una cantidad finita de patrones que podemos crear con 64 bits, lo que significa que la cantidad de números diferentes que pueden ser representados es limitada. Para una cantidad de <em>N</em> dígitos decimales, la cantidad de números que pueden ser representados es 10<sup>N</sup>. Del mismo modo, dados 64 dígitos binarios, podemos representar 2<sup>64</sup> números diferentes, lo que es alrededor de 18 trillones (un 18 con 18 ceros más). Eso es muchísimo.</p>

<p><a class="p_ident" id="p_Kq2zPrF86n" href="#p_Kq2zPrF86n" tabindex="-1" role="presentation"></a>La memoria de un computador solía ser mucho mas pequeña que en la actualidad, y las personas tendían a utilizar grupos de 8 o 16 bits para representar sus números. Era común accidentalmente <em>desbordar</em> esta limitación— terminando con un número que no cupiera dentro de la cantidad dada de bits. Hoy en día, incluso computadoras que caben dentro de tu bolsillo poseen de bastante memoria, por lo que somos libres de usar pedazos de memoria de 64 bits, y solamente nos tenemos que preocupar por desbordamientos de memoria cuando lidiamos con números verdaderamente astronómicos.</p>

<p><a class="p_ident" id="p_uUjhEvi065" href="#p_uUjhEvi065" tabindex="-1" role="presentation"></a>A pesar de esto, no todos los números enteros por debajo de 18 trillones caben en un número de JavaScript. Esos bits también almacenan números negativos, por lo que un bit indica el signo de un número. Un problema mayor es que los números no enteros tienen que ser representados también. Para hacer esto, algunos de los bits son usados para almacenar la posición del punto decimal. El número entero mas grande que puede ser almacenado está en el rango de los nueve mil billones (15 ceros), que sigue siendo inmenso.</p>

<p><a class="p_ident" id="p_QuaxCY0XYg" href="#p_QuaxCY0XYg" tabindex="-1" role="presentation"></a>Los números fraccionarios se escriben usando un punto:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_tM8nqv41Gp" href="#c_tM8nqv41Gp" tabindex="-1" role="presentation"></a><span class="cm-number">9.81</span></pre>

<p><a class="p_ident" id="p_h/9gLl2HMM" href="#p_h/9gLl2HMM" tabindex="-1" role="presentation"></a>Para números muy grandes o muy pequeños, pudiéramos también usar notación científica agregando una <em>e</em> (de “exponente”), seguida por el exponente del número:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_6ew5w+VhSM" href="#c_6ew5w+VhSM" tabindex="-1" role="presentation"></a><span class="cm-number">2.998e8</span></pre>

<p><a class="p_ident" id="p_vx7ox7vlBw" href="#p_vx7ox7vlBw" tabindex="-1" role="presentation"></a>Eso es 2.998 × 10<sup>8</sup> = 299,800,000.</p>

<p><a class="p_ident" id="p_At4IfW0/+5" href="#p_At4IfW0/+5" tabindex="-1" role="presentation"></a>Los cálculos con números enteros (también llamados <em>integers</em>) mas pequeños a los nueve mil billones anteriormente mencionados están garantizados a ser siempre precisos. Desafortunadamente, los cálculos con números fraccionarios, generalmente no lo son. Así como π (pi) no puede ser precisamente expresado por un número finito de números decimales, muchos números pierden algo de precisión cuando solo hay 64 bits disponibles para almacenarlos. Esto es una pena, pero solo causa problemas prácticos en situaciones especificas. Lo importante es que debemos ser consciente de estas limitaciones y tratar a los números fraccionarios como aproximaciones, no como valores precisos.</p>

<h3><a class="i_ident" id="i_aIf95z3S0d" href="#i_aIf95z3S0d" tabindex="-1" role="presentation"></a>Aritmética</h3>

<p><a class="p_ident" id="p_FmRykjV5fJ" href="#p_FmRykjV5fJ" tabindex="-1" role="presentation"></a>Lo que mayormente se hace con los números es aritmética. Operaciones aritméticas tales como la adición y la multiplicación, toman dos valores numéricos y producen un nuevo valor a raíz de ellos. Asi es como lucen en JavaScript:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_bSU4Vtv/mt" href="#c_bSU4Vtv/mt" tabindex="-1" role="presentation"></a><span class="cm-number">100</span> <span class="cm-operator">+</span> <span class="cm-number">4</span> <span class="cm-operator">*</span> <span class="cm-number">11</span></pre>

<p><a class="p_ident" id="p_PNPKgKWrHK" href="#p_PNPKgKWrHK" tabindex="-1" role="presentation"></a>Los símbolos <code>+</code> y <code>*</code> son llamados <em>operadores</em>. El primero representa a la adición, y el segundo representa a la multiplicación. Colocar un operador entre dos valores aplicará la operación asociada a esos valores y producirá un nuevo valor.</p>

<p><a class="p_ident" id="p_GmL94UlkG8" href="#p_GmL94UlkG8" tabindex="-1" role="presentation"></a>¿Pero el ejemplo significa “agrega 4 y 100, y multiplica el resultado por 11”, o es la multiplicación aplicada antes de la adición? Como quizás hayas podido adivinar, la multiplicación sucede primero. Pero asi como en las matemáticas, puedes cambiar este orden envolviendo la adición en paréntesis:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_ij6V90ZZBQ" href="#c_ij6V90ZZBQ" tabindex="-1" role="presentation"></a>(<span class="cm-number">100</span> <span class="cm-operator">+</span> <span class="cm-number">4</span>) <span class="cm-operator">*</span> <span class="cm-number">11</span></pre>

<p><a class="p_ident" id="p_vIfxYn0/53" href="#p_vIfxYn0/53" tabindex="-1" role="presentation"></a>Para sustraer, existe el operador <code>-</code>, y la división puede ser realizada con el operador <code>/</code>.</p>

<p><a class="p_ident" id="p_9fr/liMTtX" href="#p_9fr/liMTtX" tabindex="-1" role="presentation"></a>Cuando operadores aparecen juntos sin paréntesis, el orden en el cual son aplicados es determinado por la <em>precedencia</em> de los operadores. El ejemplo muestra que la multiplicación es aplicada antes que la adición. El operador <code>/</code> tiene la misma precedencia que <code>*</code>. Lo mismo aplica para <code>+</code> y <code>-</code>. Cuando operadores con la misma precedencia aparecen uno al lado del otro, como en <code>1 - 2 + 1</code>, estos se aplican de izquierda a derecha: <code>(1 - 2) + 1</code>.</p>

<p><a class="p_ident" id="p_7Z6z6eW7ry" href="#p_7Z6z6eW7ry" tabindex="-1" role="presentation"></a>Estas reglas de precedencia no son algo de lo que deberías preocuparte. Cuando tengas dudas, solo agrega un paréntesis.</p>

<p><a class="p_ident" id="p_7ctPjdwx0n" href="#p_7ctPjdwx0n" tabindex="-1" role="presentation"></a>Existe otro operador aritmético que quizás no reconozcas inmediatamente. El símbolo <code>%</code> es utilizado para representar la operación de <em>residuo</em>. <code>X % Y</code> es el residuo de dividir <code>X</code> entre <code>Y</code>. Por ejemplo, <code>314 % 100</code> produce <code>14</code>, y <code>144 % 12</code> produce <code>0</code>. La precedencia del residuo es la la misma que la de la multiplicación y la división. Frecuentemente veras que este operador es también conocido como <em>modulo</em>.</p>

<h3><a class="i_ident" id="i_zFIgofBZed" href="#i_zFIgofBZed" tabindex="-1" role="presentation"></a>Números especiales</h3>

<p><a class="p_ident" id="p_HqC2OH0orC" href="#p_HqC2OH0orC" tabindex="-1" role="presentation"></a>Existen 3 valores especiales en JavaScript que son considerados números pero que no se comportan como números normales.</p>

<p><a class="p_ident" id="p_sbUrefh4Fn" href="#p_sbUrefh4Fn" tabindex="-1" role="presentation"></a>Los primeros dos son <code>Infinity</code> y <code>-Infinity</code>, los cuales representan las infinidades positivas y negativas. <code>Infinity - 1</code> aun es <code>Infinity</code>, y asi sucesivamente. A pesar de esto, no confíes mucho en computaciones que dependan de infinidades. Estas no son matemáticamente confiables, y puede que muy rápidamente nos resulten en el próximo número especial: <code>NaN</code>.</p>

<p><a class="p_ident" id="p_N95yBH7Q+0" href="#p_N95yBH7Q+0" tabindex="-1" role="presentation"></a><code>NaN</code> significa “no es un número” (“Not A Number”), aunque <em>sea</em> un valor del tipo numérico. Obtendras este resultado cuando, por ejemplo, trates de calcular <code>0 / 0</code> (cero dividido entre cero), <code>Infinity - Infinity</code>, o cualquier otra cantidad de operaciones numéricas que no produzcan un resultado significante.</p>

<h2><a class="h_ident" id="h_OBbEvqxHHH" href="#h_OBbEvqxHHH" tabindex="-1" role="presentation"></a>Strings</h2>

<p><a class="p_ident" id="p_SKNvvnJC0M" href="#p_SKNvvnJC0M" tabindex="-1" role="presentation"></a>El próximo tipo de dato básico es el <em>string</em>. Los Strings son usados para representar texto. Son escritos encerrando su contenido en comillas:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_33xcklavv/" href="#c_33xcklavv/" tabindex="-1" role="presentation"></a><span class="cm-string-2">`Debajo en el mar`</span>
<span class="cm-string">&quot;Descansa en el océano&quot;</span>
<span class="cm-string">'Flota en el océano'</span></pre>

<p><a class="p_ident" id="p_BFzw/X3Koj" href="#p_BFzw/X3Koj" tabindex="-1" role="presentation"></a>Puedes usar comillas simples, comillas dobles, o comillas invertidas para representar strings, siempre y cuando las comillas al principio y al final coincidan.</p>

<p><a class="p_ident" id="p_VSHEZhK+Tt" href="#p_VSHEZhK+Tt" tabindex="-1" role="presentation"></a>Casi todo puede ser colocado entre comillas, y JavaScript construirá un valor string a partir de ello. Pero algunos caracteres son mas difíciles. Te puedes imaginar que colocar comillas entre comillas podría ser difícil. Los <em>Newlines</em> (los caracteres que obtienes cuando presionas la tecla de Enter) solo pueden ser incluidos cuando el string está encapsulado con comillas invertidas (<code>`</code>).</p>

<p><a class="p_ident" id="p_T7GgnL5b3h" href="#p_T7GgnL5b3h" tabindex="-1" role="presentation"></a>Para hacer posible incluir tales caracteres en un string, la siguiente notación es utilizada: cuando una barra invertida (<code>\</code>) es encontrada dentro de un texto entre comillas, indica que el carácter que le sigue tiene un significado especial. Esto se conoce como <em>escapar</em> el carácter. Una comilla que es precedida por una barra invertida no representará el final del string sino que formara parte del mismo. Cuando el carácter <code>n</code> es precedido por una barra invertida, este se interpreta como un Newline (salto de linea). De la mima forma, <code>t</code> después de una barra invertida, se interpreta como un character de tabulación. Toma como referencia el siguiente string:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_BR2+4hOJu9" href="#c_BR2+4hOJu9" tabindex="-1" role="presentation"></a><span class="cm-string">&quot;Esta es la primera linea\nY esta es la segunda&quot;</span></pre>

<p><a class="p_ident" id="p_kN5yuLeQgx" href="#p_kN5yuLeQgx" tabindex="-1" role="presentation"></a>El texto actual es este:</p>

<pre class="snippet cm-s-default" data-language="null" ><a class="c_ident" id="c_CNeDfYhJSz" href="#c_CNeDfYhJSz" tabindex="-1" role="presentation"></a>Esta es la primera linea
Y esta es la segunda</pre>

<p><a class="p_ident" id="p_EPLG2lcQEv" href="#p_EPLG2lcQEv" tabindex="-1" role="presentation"></a>Se encuentran, por supuesto, situaciones donde queremos que una barra invertida en un string solo sea una barra invertida, y no un carácter especial. Si dos barras invertidas prosiguen una a la otra, serán colapsadas y sólo una permanecerá en el valor resultante del string. Asi es como el string “<em>Un carácter de salto de linea es escrito así: <code>&quot;</code>\n<code>&quot;</code>.</em>” puede ser expresado:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_RgmlZHE9Ew" href="#c_RgmlZHE9Ew" tabindex="-1" role="presentation"></a><span class="cm-variable">Un</span> <span class="cm-variable">carácter</span> <span class="cm-variable">de</span> <span class="cm-variable">salto</span> <span class="cm-variable">de</span> <span class="cm-variable">linea</span> <span class="cm-variable">es</span> <span class="cm-variable">escrito</span> <span class="cm-variable">así</span>: \<span class="cm-string">&quot;\\n\&quot;.&quot;</span></pre>

<p id="unicode"><a class="p_ident" id="p_9/EpypIB6p" href="#p_9/EpypIB6p" tabindex="-1" role="presentation"></a>También los strings deben de ser modelados como una serie de bits para poder existir dentro del computador. La forma en la que JavaScript hace esto es basada en el estándar <em>Unicode</em>. Este estándar asigna un número a todo carácter que alguna vez pudieras necesitar, incluyendo caracteres en Griego, Árabe, Japones, Armenio, y asi sucesivamente. Si tenemos un número para representar cada carácter, un string puede ser descrito como una secuencia de números.</p>

<p><a class="p_ident" id="p_7kWbp4Y2DE" href="#p_7kWbp4Y2DE" tabindex="-1" role="presentation"></a>Y eso es lo que hace JavaScript. Pero hay una complicación: La representación de JavaScript usa 16 bits por cada elemento string, en el cual caben 2<sup>16</sup> números diferentes. Pero Unicode define mas caracteres que aquellos—aproximadamente el doble, en este momento. Entonces algunos caracteres, como muchos emojis, necesitan ocupar dos “posiciones de caracteres” en los strings de JavaScript. Volveremos a este tema en el <a href="orden_superior#unidades_de_codigo">Capitulo 5</a>.</p>

<p><a class="p_ident" id="p_sDVemokRuP" href="#p_sDVemokRuP" tabindex="-1" role="presentation"></a>Los strings no pueden ser divididos, multiplicados, o substraidos, pero el operador <code>+</code> <em>puede</em> ser utilizado en ellos. No los agrega, sino que los <em>concatena</em>—pega dos strings juntos. La siguiente línea producirá el string <code>&quot;concatenar&quot;</code>:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_AF1pg1pIWq" href="#c_AF1pg1pIWq" tabindex="-1" role="presentation"></a><span class="cm-string">&quot;con&quot;</span> <span class="cm-operator">+</span> <span class="cm-string">&quot;cat&quot;</span> <span class="cm-operator">+</span> <span class="cm-string">&quot;e&quot;</span> <span class="cm-operator">+</span> <span class="cm-string">&quot;nar&quot;</span></pre>

<p><a class="p_ident" id="p_lfT8rxBQKp" href="#p_lfT8rxBQKp" tabindex="-1" role="presentation"></a>Los valores string tienen un conjunto de funciones (<em>métodos</em>) asociadas, que pueden ser usadas para realizar operaciones en ellos. Regresaremos a estas en el <a href="datos#metodos">Capítulo 4</a>.</p>

<p><a class="p_ident" id="p_VPMd3SuiWd" href="#p_VPMd3SuiWd" tabindex="-1" role="presentation"></a>Los strings escritos con comillas simples o dobles se comportan casi de la misma manera—La unica diferencia es el tipo de comilla que necesitamos para escapar dentro de ellos. Los strings de comillas inversas, usualmente llamados <em>plantillas literales</em>, pueden realizar algunos trucos más. Mas alla de permitir saltos de lineas, pueden también incrustar otros valores.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Q70paqTNYa" href="#c_Q70paqTNYa" tabindex="-1" role="presentation"></a><span class="cm-string-2">`la mitad de 100 es ${</span><span class="cm-number">100</span> <span class="cm-operator">/</span> <span class="cm-number">2</span><span class="cm-string-2">}</span><span class="cm-string-2">`</span></pre>

<p><a class="p_ident" id="p_6tfJCNVaMB" href="#p_6tfJCNVaMB" tabindex="-1" role="presentation"></a>Cuando escribes algo dentro de <code>${}</code> en una plantilla literal, el resultado será computado, convertido a string, e incluido en esa posición. El ejemplo anterior produce “<em>la mitad de 100 es 50</em>”.</p>

<h2><a class="h_ident" id="h_Ba/lVluC/D" href="#h_Ba/lVluC/D" tabindex="-1" role="presentation"></a>Operadores unarios</h2>

<p><a class="p_ident" id="p_2UH+luNgL7" href="#p_2UH+luNgL7" tabindex="-1" role="presentation"></a>No todo los operadores son simbolos. Algunos se escriben como palabras. Un ejemplo es el operador <code>typeof</code>, que produce un string con el nombre del tipo de valor que le demos.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_iWT//VyY7j" href="#c_iWT//VyY7j" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">typeof</span> <span class="cm-number">4.5</span>)
<span class="cm-comment">// → number</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-keyword">typeof</span> <span class="cm-string">&quot;x&quot;</span>)
<span class="cm-comment">// → string</span></pre>

<p id="console.log"><a class="p_ident" id="p_xUIbfeG70w" href="#p_xUIbfeG70w" tabindex="-1" role="presentation"></a>Usaremos <code>console.log</code> en los ejemplos de código para indicar que que queremos ver el resultado de alguna evaluación. Mas acerca de esto esto en el <a href="estructura_de_programa">proximo capitulo</a>.</p>

<p><a class="p_ident" id="p_NlvaU7N7ZP" href="#p_NlvaU7N7ZP" tabindex="-1" role="presentation"></a>En los otros operadores que hemos visto hasta ahora, todos operaban en dos valores, pero <code>typeof</code> sola opera con un valor. Los operadores que usan dos valores son llamados operadores <em>binarios</em>, mientras que aquellos operadores que usan uno son llamados operadores <em>unarios</em>. El operador menos puede ser usado tanto como un operador binario o como un operador unario.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_VpL89RFAPj" href="#c_VpL89RFAPj" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-operator">-</span> (<span class="cm-number">10</span> <span class="cm-operator">-</span> <span class="cm-number">2</span>))
<span class="cm-comment">// → -8</span></pre>

<h2><a class="h_ident" id="h_qmf/1Mk6oH" href="#h_qmf/1Mk6oH" tabindex="-1" role="presentation"></a>Valores Booleanos</h2>

<p><a class="p_ident" id="p_AEXqFWwKyF" href="#p_AEXqFWwKyF" tabindex="-1" role="presentation"></a>Es frecuentemente util tener un valor que distingue entre solo dos posibilidades, como “si”, y “no”, o “encendido” y “apagado”. Para este propósito, JavaScript tiene el tipo <em>Boolean</em>, que tiene solo dos valores: true (verdadero) y false (falso) que se escriben de la misma forma.</p>

<h3><a class="i_ident" id="i_j8pkHXp4wK" href="#i_j8pkHXp4wK" tabindex="-1" role="presentation"></a>Comparación</h3>

<p><a class="p_ident" id="p_pgDFbIHv1e" href="#p_pgDFbIHv1e" tabindex="-1" role="presentation"></a>Aquí se muestra una forma de producir valores Booleanos:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_GaxnXrIPwC" href="#c_GaxnXrIPwC" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-number">3</span> <span class="cm-operator">&gt;</span> <span class="cm-number">2</span>)
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-number">3</span> <span class="cm-operator">&lt;</span> <span class="cm-number">2</span>)
<span class="cm-comment">// → false</span></pre>

<p><a class="p_ident" id="p_FhUaNerlfU" href="#p_FhUaNerlfU" tabindex="-1" role="presentation"></a>Los signos <code>&gt;</code> y <code>&lt;</code> son tradicionalmente símbolos para “mayor que” y “menor que”, respectivamente. Ambos son operadores binarios. Aplicarlos resulta en un valor Boolean que indica si la condición que indican se cumple.</p>

<p><a class="p_ident" id="p_uPrGUadipb" href="#p_uPrGUadipb" tabindex="-1" role="presentation"></a>Los Strings pueden ser comparados de la misma forma.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Qud5plnVuV" href="#c_Qud5plnVuV" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Aardvark&quot;</span> <span class="cm-operator">&lt;</span> <span class="cm-string">&quot;Zoroaster&quot;</span>)
<span class="cm-comment">// → true</span></pre>

<p><a class="p_ident" id="p_89ZFJuecbl" href="#p_89ZFJuecbl" tabindex="-1" role="presentation"></a>La forma en la que los strings son ordenados, es aproximadamente alfabético, aunque no realmente de la misma forma que esperaríamos ver en un diccionario: las letras mayúsculas son siempre “menores que” las letras minúsculas, así que <code>&quot;Z&quot; &lt; &quot;a&quot;</code>, y caracteres no alfabéticos (como <code>!</code>, <code>-</code> y demás) son también incluidos en el ordenamiento. Cuando comparamos strings, JavaScript evalúa los caracteres  de izquierda a derecha, comparando los códigos Unicode uno por uno.</p>

<p><a class="p_ident" id="p_LWMB/exwEI" href="#p_LWMB/exwEI" tabindex="-1" role="presentation"></a>Otros operadores similares son <code>&gt;=</code> (mayor o igual que), <code>&lt;=</code> (menor o igual que), <code>==</code> (igual a), y <code>!=</code> (no igual a).</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_s0f1sN/Np/" href="#c_s0f1sN/Np/" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Itchy&quot;</span> <span class="cm-operator">!=</span> <span class="cm-string">&quot;Scratchy&quot;</span>)
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Manzana&quot;</span> <span class="cm-operator">==</span> <span class="cm-string">&quot;Naranja&quot;</span>)
<span class="cm-comment">// → false</span></pre>

<p><a class="p_ident" id="p_qeF5rEgoVg" href="#p_qeF5rEgoVg" tabindex="-1" role="presentation"></a>Solo hay un valor en JavaScript que no es igual a si mismo, y este es <code>NaN</code> (“no es un número”).</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_Vhz09Rgw3h" href="#c_Vhz09Rgw3h" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-atom">NaN</span> <span class="cm-operator">==</span> <span class="cm-atom">NaN</span>)
<span class="cm-comment">// → false</span></pre>

<p><a class="p_ident" id="p_HXganV4c6o" href="#p_HXganV4c6o" tabindex="-1" role="presentation"></a>Se supone que <code>NaN</code> denota el resultado de una computación sin sentido, y como tal, no es igual al resultado de ninguna <em>otra</em> computación sin sentido.</p>

<h3><a class="i_ident" id="i_gt6oADpxuG" href="#i_gt6oADpxuG" tabindex="-1" role="presentation"></a>Operadores lógicos</h3>

<p><a class="p_ident" id="p_ViGOoJae91" href="#p_ViGOoJae91" tabindex="-1" role="presentation"></a>También existen algunas operaciones que pueden ser aplicadas a valores Booleanos. JavaScript soporta tres operadores lógicos: <em>and</em>, <em>or</em>, y <em>not</em>. Estos pueden ser usados para “razonar” acerca de valores Booleanos.</p>

<p><a class="p_ident" id="p_lTsXHG2lrz" href="#p_lTsXHG2lrz" tabindex="-1" role="presentation"></a>El operador <code>&amp;&amp;</code> representa el operador lógico <em>and</em>. Es un operador binario, y su resultado es verdadero solo si ambos de los valores dados son verdaderos.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_SHi38sNkwM" href="#c_SHi38sNkwM" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-atom">true</span> <span class="cm-operator">&amp;</span><span class="cm-operator">&amp;</span> <span class="cm-atom">false</span>)
<span class="cm-comment">// → false</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-atom">true</span> <span class="cm-operator">&amp;</span><span class="cm-operator">&amp;</span> <span class="cm-atom">true</span>)
<span class="cm-comment">// → true</span></pre>

<p><a class="p_ident" id="p_CUv4iRpVzs" href="#p_CUv4iRpVzs" tabindex="-1" role="presentation"></a>El operador <code>||</code> representa el operador lógico <em>or</em>. Lo que produce es verdadero si cualquiera de los valores dados es verdadero.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_diXyv7iPd1" href="#c_diXyv7iPd1" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-atom">false</span> <span class="cm-operator">|</span><span class="cm-operator">|</span> <span class="cm-atom">true</span>)
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-atom">false</span> <span class="cm-operator">|</span><span class="cm-operator">|</span> <span class="cm-atom">false</span>)
<span class="cm-comment">// → false</span></pre>

<p><a class="p_ident" id="p_yd+g1Em++r" href="#p_yd+g1Em++r" tabindex="-1" role="presentation"></a><em>Not</em> se escribe como un signo de exclamación (<code>!</code>). Es un operador unario que voltea el valor dado—<code>!true</code> produce <code>false</code> y <code>!false</code> produce <code>true</code>.</p>

<p><a class="p_ident" id="p_yrCQyMdqA+" href="#p_yrCQyMdqA+" tabindex="-1" role="presentation"></a>Cuando estos operadores Booleanos son mezclados con aritmética y con otros operadores, no siempre es obvio cuando son necesarios los paréntesis. En la práctica, usualmente puedes manejarte bien sabiendo que de los operadores que hemos visto hasta ahora, <code>||</code> tiene la menor precedencia, luego le sigue <code>&amp;&amp;</code>, luego le siguen los operadores de comparación (<code>&gt;</code>, <code>==</code>, y demás), y luego el resto. Este orden ha sido determinado para que en expresiones como la siguiente, la menor cantidad de paréntesis posible sea necesaria:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_6eZ07bDo11" href="#c_6eZ07bDo11" tabindex="-1" role="presentation"></a><span class="cm-number">1</span> <span class="cm-operator">+</span> <span class="cm-number">1</span> <span class="cm-operator">==</span> <span class="cm-number">2</span> <span class="cm-operator">&amp;</span><span class="cm-operator">&amp;</span> <span class="cm-number">10</span> <span class="cm-operator">*</span> <span class="cm-number">10</span> <span class="cm-operator">&gt;</span> <span class="cm-number">50</span></pre>

<p><a class="p_ident" id="p_tPm5rEel5A" href="#p_tPm5rEel5A" tabindex="-1" role="presentation"></a>El ultimo operador lógico que discutiremos no es unario, tampoco binario, sino <em>ternario</em>, esto es, que opera en tres valores. Es escrito con un signo de interrogación y dos puntos, de esta forma:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_G7eVm8ilWm" href="#c_G7eVm8ilWm" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-atom">true</span> <span class="cm-operator">?</span> <span class="cm-number">1</span> : <span class="cm-number">2</span>);
<span class="cm-comment">// → 1</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-atom">false</span> <span class="cm-operator">?</span> <span class="cm-number">1</span> : <span class="cm-number">2</span>);
<span class="cm-comment">// → 2</span></pre>

<p><a class="p_ident" id="p_Qgctno+nHm" href="#p_Qgctno+nHm" tabindex="-1" role="presentation"></a>Este es llamado el operador <em>condicional</em> (o algunas veces simplemente operador <em>ternario</em> ya que solo existe uno de este tipo). El valor a la izquierda del signo de interrogación “decide” cual de los otros dos valores sera retornado. Cuando es verdadero, elige el valor de en medio, y cuando es falso, el valor de la derecha.</p>

<h2><a class="h_ident" id="h_u3yR/DNtwV" href="#h_u3yR/DNtwV" tabindex="-1" role="presentation"></a>Valores vacíos</h2>

<p><a class="p_ident" id="p_FR/nkZsdGX" href="#p_FR/nkZsdGX" tabindex="-1" role="presentation"></a>Existen dos valores especiales, escritos como <code>null</code> y <code>undefined</code>, que son usados para denotar la ausencia de un valor <em>significativo</em>. Son en si mismos valores, pero no traen consigo información.</p>

<p><a class="p_ident" id="p_KPBuVm+Itl" href="#p_KPBuVm+Itl" tabindex="-1" role="presentation"></a>Muchas operaciones en el lenguaje que no producen un valor significativo (veremos algunas mas adelante), producen <code>undefined</code> simplemente porque tienen que producir <em>algún</em> valor.</p>

<p><a class="p_ident" id="p_3jaQGJs1GN" href="#p_3jaQGJs1GN" tabindex="-1" role="presentation"></a>La diferencia en significado entre <code>undefined</code> y <code>null</code> es un accidente del diseño de JavaScript, y realmente no importa la mayor parte del tiempo. En los casos donde realmente tendríamos que preocuparnos por estos valores, mayormente recomiendo que los trates como intercambiables.</p>

<h2><a class="h_ident" id="h_fjaBPMb9FH" href="#h_fjaBPMb9FH" tabindex="-1" role="presentation"></a>Conversión de tipo automática</h2>

<p><a class="p_ident" id="p_hiiKbgQYbK" href="#p_hiiKbgQYbK" tabindex="-1" role="presentation"></a>En la Introducción, mencione que JavaScript tiende a salirse de su camino para aceptar casi cualquier programa que le demos, incluso programas que hacen cosas extrañas. Esto es bien demostrado por las siguientes expresiones:</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_15oJuww9Nn" href="#c_15oJuww9Nn" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-number">8</span> <span class="cm-operator">*</span> <span class="cm-atom">null</span>)
<span class="cm-comment">// → 0</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;5&quot;</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>)
<span class="cm-comment">// → 4</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;5&quot;</span> <span class="cm-operator">+</span> <span class="cm-number">1</span>)
<span class="cm-comment">// → 51</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;cinco&quot;</span> <span class="cm-operator">*</span> <span class="cm-number">2</span>)
<span class="cm-comment">// → NaN</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-atom">false</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>)
<span class="cm-comment">// → true</span></pre>

<p><a class="p_ident" id="p_5TyEq8scm+" href="#p_5TyEq8scm+" tabindex="-1" role="presentation"></a>Cuando un operador es aplicado al tipo de valor “incorrecto”, JavaScript silenciosamente convertirá ese valor al tipo que necesita, utilizando una serie de reglas que frecuentemente no dan el resultado que quisieras o esperarías. Esto es llamado <em>coercion de tipo</em>. El <code>null</code> en la primera expresión se torna <code>0</code>, y el <code>&quot;5&quot;</code>en la segunda expresión se torna <code>5</code> (de string a número). Sin embargo, en la tercera expresión, <code>+</code> intenta realizar una concatenación de string antes que una adición numérica, entonces el <code>1</code> es convertido a <code>&quot;1&quot;</code> (de número a string)</p>

<p><a class="p_ident" id="p_jcnJfAvvp6" href="#p_jcnJfAvvp6" tabindex="-1" role="presentation"></a>Cuando algo que no se traduce a un número en una manera obvia (tal como <code>&quot;cinco&quot;</code> o <code>undefined</code>) es convertido a un número, obtenemos el valor <code>NaN</code>. Operaciones aritméticas subsecuentes con <code>NaN</code>, continúan produciendo <code>NaN</code>, asi que si te encuentras obteniendo uno de estos valores en algun lugar inesperado, busca por coerciones de tipo accidentales.</p>

<p><a class="p_ident" id="p_G0QDVONK6Z" href="#p_G0QDVONK6Z" tabindex="-1" role="presentation"></a>Cuando se utiliza <code>==</code> para comparar valores del mismo tipo, el desenlace es fácil de predecir: debemos de obtener verdadero cuando ambos valores son lo mismo, excepto en el caso de <code>NaN</code>. Pero cuando los tipos difieren, JavaScript utiliza una serie de reglas complicadas y confusas para determinar que hacer. En la mayoria de los casos, solo tratara de convertir uno de estos valores al tipo del otro valor. Sin embargo, cuando <code>null</code> o <code>undefined</code> ocurren en cualquiera de los lados del operador, este produce verdadero solo si ambos lados son valores o <code>null</code> o <code>undefined</code>.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_qmGDPdETlf" href="#c_qmGDPdETlf" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-atom">null</span> <span class="cm-operator">==</span> <span class="cm-atom">undefined</span>);
<span class="cm-comment">// → true</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-atom">null</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>);
<span class="cm-comment">// → false</span></pre>

<p><a class="p_ident" id="p_dcNtvpW/rd" href="#p_dcNtvpW/rd" tabindex="-1" role="presentation"></a>Este comportamiento es frecuentemente util. Cuando queremos probar si un valor tiene un valor real en vez de <code>null</code> o <code>undefined</code>, puedes compararlo con <code>null</code> usando el operador <code>==</code> (o <code>!=</code>).</p>

<p><a class="p_ident" id="p_T6yOogY3+p" href="#p_T6yOogY3+p" tabindex="-1" role="presentation"></a>Pero que pasa si queremos probar que algo se refiere precisamente al valor <code>false</code>? Las reglas para convertir strings y números a valores Booleanos, dice que <code>0</code>, <code>NaN</code>, y el string vació (<code>&quot;&quot;</code>) cuentan como <code>false</code>, mientras que todos los otros valores cuentan como <code>true</code>. Debido a esto, expresiones como <code>0 == false</code>, y <code>&quot;&quot; == false</code> son también verdaderas. Cuando no queremos ninguna conversion de tipo automática, existen otros dos operadores adicionales: <code>===</code> y <code>!==</code>. El primero prueba si un valor es <em>precisamente</em> igual al otro, y el segundo prueba si un valor no es precisamente igual. Entonces <code>&quot;&quot; === false</code> es falso, como es de esperarse.</p>

<p><a class="p_ident" id="p_pjRNAOsHp5" href="#p_pjRNAOsHp5" tabindex="-1" role="presentation"></a>Recomiendo usar el operador de comparación de tres caracteres de una manera defensiva para prevenir que conversiones de tipo inesperadas te estorben. Pero cuando estés seguro de que el tipo va a ser el mismo en ambos lados, no es problemático utilizar los operadores mas cortos.</p>

<h3><a class="i_ident" id="i_nAm5vED6NZ" href="#i_nAm5vED6NZ" tabindex="-1" role="presentation"></a>Corto circuito de operadores lógicos</h3>

<p><a class="p_ident" id="p_A9D5HtkPkh" href="#p_A9D5HtkPkh" tabindex="-1" role="presentation"></a>Los operadores lógicos <code>&amp;&amp;</code> y <code>||</code>, manejan valores de diferentes tipos de una forma peculiar. Ellos convertirán el valor en su lado izquierdo a un tipo Booleano para decidir que hacer, pero dependiendo del operador y el resultado de la conversión, devolverán o el valor <em>original</em> de la izquierda o el valor de la derecha.</p>

<p><a class="p_ident" id="p_cuUBBNUCnX" href="#p_cuUBBNUCnX" tabindex="-1" role="presentation"></a>El operador <code>||</code>, por ejemplo, devolverá el valor de su izquierda cuando este puede ser convertido a verdadero y de ser lo contrario devolverá el valor de la derecha. Esto tiene el efecto esperado cuando los valores son Booleanos, pero se comporta de una forma algo análoga con valores de otros tipos.</p>

<pre class="snippet cm-s-default" data-language="javascript" ><a class="c_ident" id="c_2QvcXTa0ga" href="#c_2QvcXTa0ga" tabindex="-1" role="presentation"></a><span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-atom">null</span> <span class="cm-operator">|</span><span class="cm-operator">|</span> <span class="cm-string">&quot;usuario&quot;</span>)
<span class="cm-comment">// → usuario</span>
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-string">&quot;Agnes&quot;</span> <span class="cm-operator">|</span><span class="cm-operator">|</span> <span class="cm-string">&quot;usuario&quot;</span>)
<span class="cm-comment">// → Agnes</span></pre>

<p><a class="p_ident" id="p_uxlWWOZQy0" href="#p_uxlWWOZQy0" tabindex="-1" role="presentation"></a>Podemos utilizar esta funcionalidad como una forma de recurrir a un valor por defecto. Si tenemos un valor que puede estar vacío, podemos usar <code>||</code> después de este para remplazarlo con otro valor. Si el valor inicial puede ser convertido a falso, obtendra el reemplazo en su lugar.</p>

<p><a class="p_ident" id="p_n4FwgZC7fF" href="#p_n4FwgZC7fF" tabindex="-1" role="presentation"></a>El operador <code>&amp;&amp;</code> funciona de manera similar, pero de forma opuesta. Cuando el valor a su izquierda es algo que se convierte a falso, devuelve ese valor, y de lo contrario, devuelve el valor a su derecha.</p>

<p><a class="p_ident" id="p_f2xPF4l91f" href="#p_f2xPF4l91f" tabindex="-1" role="presentation"></a>Otra propiedad importante de estos dos operadores es que la parte de su derecha solo es evaluada si es necesario. En el caso de de <code>true || X</code>, no importa que sea <code>X</code>—aun si es una pieza del programa que hace algo <em>terrible</em>—el resultado será verdadero, y <code>X</code> nunca sera evaluado. Lo mismo sucede con <code>false &amp;&amp; X</code>, que es falso e ignorará <code>X</code>. Esto es llamado <em>evaluación de corto circuito</em>.</p>

<p><a class="p_ident" id="p_66krLWx0l4" href="#p_66krLWx0l4" tabindex="-1" role="presentation"></a>El operador condicional funciona de manera similar. Del segundo y tercer valor, solo el que es seleccionado es evaluado.</p>

<h2><a class="h_ident" id="h_NUFOUyK+lw" href="#h_NUFOUyK+lw" tabindex="-1" role="presentation"></a>Resumen</h2>

<p><a class="p_ident" id="p_03pT52+bGg" href="#p_03pT52+bGg" tabindex="-1" role="presentation"></a>Observamos cuatro tipos de valores de JavaScript en este capítulo: números, textos (<code>strings</code>), Booleanos, y valores indefinidos.</p>

<p><a class="p_ident" id="p_yWVTJP0zq/" href="#p_yWVTJP0zq/" tabindex="-1" role="presentation"></a>Tales valores son creados escribiendo su nombre (<code>true</code>, <code>null</code>) o valor (<code>13</code>, <code>&quot;abc&quot;</code>). Puedes combinar y transformar valores con operadores. Vimos operadores binarios para aritmética (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, y <code>%</code>), concatenación de strings (<code>+</code>), comparaciones (<code>==</code>, <code>!=</code>, <code>===</code>, <code>!==</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>), y lógica (<code>&amp;&amp;</code>, <code>||</code>), así también como varios otros operadores unarios (<code>-</code> para negar un número, <code>!</code> para negar lógicamente, y <code>typeof</code> para saber el valor de un tipo) y un operador ternario (<code>?:</code>) para elegir uno de dos valores basándose en un tercer valor.</p>

<p><a class="p_ident" id="p_t9mcSdQmtV" href="#p_t9mcSdQmtV" tabindex="-1" role="presentation"></a>Esto te dá la información suficiente para usar JavaScript como una calculadora de bolsillo, pero no para mucho más. El <a href="estructura_de_programa">próximo capitulo</a> empezará a juntar estas expresiones para formar programas básicos.</p><nav><a href="00_intro.html" title="previous chapter">◀</a> <a href="index.html" title="cover">◆</a> <a href="02_program_structure.html" title="next chapter">▶</a></nav>
</article>
